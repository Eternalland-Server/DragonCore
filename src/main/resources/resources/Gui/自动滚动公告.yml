
#毫秒
每轮时间: 6000

公告数: 6
# 公告列表，从0开始，每次+1
0: "千万别打开聊天栏点我"
1: "第1行公告"
2: "第2行公告"
3: "第3行公告"
4: "第4行公告"
5: "第5行公告"






# 如果你不想学习Gui制作方法，只需要看上面的设置即可



# 匹配打开的界面名，若一致时会替换界面 
match: "hud"

# 该处的方法可利用【方法.执行方法('ggg')】或【方法.异步执行方法('ggg')】来执行
Functions:
  # 首先界面打开时，会自动触发open方法，然后读取yml的值并保存为界面变量
  # 然后开始异步执行方法，为什么要异步？是因为只有在异步方法里才可以用延时方法
  open: |-
    界面变量.时间=方法.取yaml值('每轮时间');
    界面变量.公告数=方法.取yaml值('公告数')-1;
    方法.异步执行方法('xxx')
  # 第一行: 利用yml读取方法，取出当前准备播放的公告行
  #    使用[方法.到整数]的原因是 所有的数值都是小数，如果直接用 
  #    方法.取yaml值(界面变量.计数) 那么读到的节点是 0.0 1.0 2.0 这样的值，而不是0 1 2
  #    那就取不到正确的公告了
  # 第二行: 获取公告文本的宽度 并 乘以它的缩放大小
  #    这是因为我们想让公告从最左边看不见的地方一点一点出来
  #    又得适配公告的长度，所以得获取文本长度然后在x那里减少
  # 注意事项: 为什么使用的是界面变量而不是局部变量呢，因为我们下面为x设置的是一道计算式
  #    它每次绘制的时候才会去取得 [文本宽度] 的值，如果你设置的是局部变量，那么绘制的时候是取不到值的
  # 第三行: 读取当前时间并储存到界面变量里
  # 第四行: 为公告栏设置x值
  # 第五行: 计数+1
  # 第八行: 一个判断表达式->   (条件) ? {执行方法}:0;  
  xxx: |-
    界面变量.文本=方法.取yaml值(方法.到整数(界面变量.计数));
    界面变量.文本宽度 = 方法.取文本宽度(界面变量.文本)*方法.取组件值('公告栏_label','scale')+100;
    界面变量.开始时间 = 方法.取当前时间;
    方法.设置组件值('公告栏_label','x','(方法.取当前时间-界面变量.开始时间) * ((方法.取屏幕宽度+界面变量.文本宽度)/界面变量.时间) - 界面变量.文本宽度');
    方法.延时(界面变量.时间);
    界面变量.计数=界面变量.计数+1;
    (界面变量.计数>界面变量.公告数) ? {界面变量.计数=0;}:0;
    方法.异步执行方法('xxx');

    


公告栏_label:
  y: 20
  width: 0
  height: 0
  texts: "界面变量.文本"
  scale: 2
  actions:
    # 当显示第0行时，玩家点击会让玩家发出聊天消息
    click_left: "(界面变量.计数==0)?方法.聊天('我是傻逼'):0"
